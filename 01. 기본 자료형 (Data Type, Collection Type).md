이번 글에서는 데이터 타입(Data Type)과 컬렉션 타입(Collection Type)에 대해 다뤄보려 합니다.

Swift는 **안전성**(Safety)을 굉장히 중시하는 단어이기 때문에, 

서로 다른 타입끼리 대입을 하거나 연산을 하는 데 있어 많은 제약을 받게 됩니다. 

그래서 여러가지 타입을 잘 알아두고, 각각 상황에 맞추어서 활용할 수 있도록 공부를 해둘 필요가 있습니다 :)

### 1. Data Type

**1) Bool**

Boolean의 약자로, true/false 를 담을 수 있다. (다른 언어처럼 0, 1은 대입할 수 없음)

```swift
var someBool: Bool = true
someBool = 1               // 컴파일 오류 발생
someBool = (1 == 0)        // false
```

**2) Int**

Integer의 약자로, 정수 타입의 데이터를 모두 담을 수 있다.

```swift
var someInt: Int = 100
someInt = 100.7             // 컴파일 오류 발생
```

**3) UInt**

Unsigned Integer의 약자로, 양의 정수 타입(0 포함)의 데이터를 모두 담을 수 있다.

<주의> Int 변수를 UInt 변수에 대입하면 컴파일 에러 발생!!

```swift
var someInt: Int = 100
var someUInt: UInt = 100
someUInt = -100             // 컴파일 오류 발생
someUInt = someUInt         // 컴파일 오류 발생
```

**4) float, double**

각각 32비트, 64비트 실수를 담을 수 있다.

```swift
var someFloat: Float = 3.14
someFloat = 3

var someDouble: Double = 3.14
someDouble = 3

someFloat = someDouble     // 컴파일 오류 발생 (다른 타입 집어넣는걸 참 예민하게 반응하네요 ^_^)
```

**5) Character**

문자를 담을 수 있는 타입이다.

```swift
var someCharacter: Character = "아"
someCharacter = "💡"
// someCharacter = "하하하"      // 컴파일 오류 발생
```

**6) String**

문자열를 담을 수 있는 타입

```swift
var someString: String = "안녕하세요"
someString = someString + "저는 민재입니다."

// someString = someCharacter     // 컴파일 오류 발생

someString = """
스트링에서는
여러줄
문자열을
이렇게
사용합니다.
"""

/*
""" 이렇게 쓰면
오류가 발생합니다."""
*/
```

하지만 위에서 배운 데이터 타입을 제외하고, Swift에서 특이한 특징을 가지고 있는 데이터 타입들이 있습니다!

바로 Any와 AnyObject라는 타입인데요, 이 두 녀석은

**"모든 데이터 타입 / 모든 클래스의 인스턴스를 넣을 수 있다"**는 특징을 각각 갖고 있습니다 ^__^

**7) Any**

다양한 데이터 타입의 값을 수용하는 것이 가능함.

**<주의> Any 데이터 형을 대입하려면, 반드시 !형 변환이 필요하다**

```swift
var someAny: Any = 100
someAny = "어떤 값도 들어올 수 있지요"
someAny = 100.8
```

**8) AnyObject**

클래스의 인스턴스라면 모두 대입 할 수 있다. 

**<주의> 클래스의 인스턴스 값만 대입 가능하기 때문에, 일반 데이터 형을 대입하면 에러가 발생**

```swift
class someClass {}
var someAnyObject: AnyObject = someClass()

someAnyObject = 132.12      // 컴파일 오류 발생
```

**9) nil**

- '없음'을 의미하는 스위프트 키워드
- <추가> 옵셔널 변수에만 대입이 가능한 키워드이다.
- <주의> Any와 AnyObject에는 nil 대입이 불가하다.

### 2. Collection Type

Swift에서는 데이터의 집합(컬렉션)을 3가지 형태(Array, Set, Dictionary)로 나누어서 제공합니다.

**1) Array**

순서가 있는 리스트 컬렉션 

```swift
var someArray: Array<Int> = Array<Int>()      // someArray: [Int] = []

someArray.append(10)            // 원소 추가
someArray.contains(100)         // Array에 원소가 있는지 확인
someArray.remove(at: 0)         // 0번째 index에 있는 원소를 지웁니다 
someArray.removeLast()          // 마지막 원소 지우기
someArray.removeAll()           // 모든 원소 지우기
someArray.count                 // 원소의 개수만큼 Int로 반환
someArray.firstIndex(of: 원소)   // 해당 원소가 가장 첫번째로 나오는 index를 알고 싶다면
someArray.lastIndex(of: 원소)    // 해당 원소가 가장 마지막으로 나오는 index를 알고 싶다면
someArray[0] = 99               // 원소를 교체
```

**2) Dictionary**

Key-Value 쌍으로 이루어진 데이터 컬렉션

```swift
var someDic: [Int: String] = [:]     // someDic: Dictionary = [Int:String]()

var someDic2: [Int: String] = [1: "Apple", 2: "Banana", 3: "Chocolate"]

someDic2[3] = "cocoa"             // Key값으로 Value를 수정
someDic2[4] = "dog"               // Key값으로 새로운 데이터를 추가
someDic2.removeValue(forKey: 4)   // Key값으로 데이터 지우기
someDic2.removeAll()              // 모든 데이터 지우기

someDic2[1]!    // Dictionary값에 접근할 때 (옵셔널로 변환해야함)
someDic2[100]!  // nil 반환
someDic2[1]     // 에러
```

**3) Set**

순서가 존재하지 않고, 멤버가 유일한 것을 보장하는 데이터 컬렉션

- 원소의 삽입, 삭제, 갯수의 메소드는 `Array`와 동일
- 순서가 없기 때문에, index를 통해 접근하는 것은 불가능하다.


Swift에서 타입 캐스팅은 **해당 인스턴스의 타입이 무엇인지?**

혹은 **해당 인스턴스를 부모 혹은 자식 타입처럼 사용 할 수 있는지?**를 처리하기 위해 사용됩니다.

### 1. is

**"너는 정말 해당 타입에 해당하니?"**

```swift
(인스턴스) is (타입)
// 해당 인스턴스가 우측의 타입에 해당하는지 아닌지 true/false로 반환
// Bool값을 반환하므로, if문/switch문을 활용해 다채롭게 표현할 수 있음
```

### 2. as

**"너가 자식 클래스이지만, 이번 만큼은 부모 클래스인척 해줘" (업 캐스팅)**

```swift
(자식 클래스 인스턴스) as (부모 클래스 인스턴스)

// UniversityStudent 인스턴스를 생성하여, Person 행세를 할 수 있도록 업 캐스팅
var minjae: Person = UniversityStudent() as Person

// UniversityStudent 인스턴스를 생성하여, Any 행세를 할 수 있도록 업 캐스팅
var minjae: Any = UniversityStudent()    // UniversityStudent() **as Any** 생략가능
```

### 3. as?

**"성공할지는 모르겠는데, 나를 이런 타입으로 여겨줄 수 있어?" (조건부 다운 캐스팅)**

```swift
// 예시1

class MediaItem {
        var name: String
        init(name: String) {
                self.name = name
        }
}

class Movie: MediaItem {
        var director: String
        init(name: String, director: String) {
                self.director = director
                super.init(name: name)
        }
}

class Song: MediaItem {
        var artist: String
        init(name: String, artist: String) {
                self.artist = artist
                super.init(name: name)
        }
}

// library라는 배열은 Movie와 Song을 모두 상속하고 있는 MediaItem 형의 배열로 정의되어 있음
let library = [
        Movie(name: "어바웃 타임", director: "리처드 어쩌구")
        Song(name: "지코", artist: "아는 노래")
]

// as? 사용 부분
for item in library {
        if let movie = item as? Movie {
                무비로 다운 캐스팅이 가능할때 나오는 부분
        }
        else if let song = item as? Song {
                송으로 다운 캐스팅이 가능할때 나오는 부분
        }
}
```

```swift
// 예시2

let personName: String = notification.object as? String ?? "이름"
```

### 4. as!

**"반드시 이 타입으로 여겨줘!" (강제 다운 캐스팅)**

```swift
(인스턴스) as! (클래스 네임)

// 반드시 이것은 String형으로 형변환이 성공한다
let personName: String = notification.object as! String
```
