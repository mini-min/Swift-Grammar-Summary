
옵셔널(Optional)은 Swift의 언어적 특징을 가장 잘 나타내 주는 부분이자, 가장 중요한 부분입니다.

Swift는 앞에서도 말했듯이 안전성을 굉장히 중시하는 언어로

전체적으로 프로그래머가 행할 수 있는 실수를 문법 차원에서 미연에 방지할 수 있도록 되어 있는데,

그 일환으로 옵셔널(Optional)이라는 문법, guard구문, 오류처리, 강력한 타입 통제 등 다른 언어에서는 볼 수 없는 강력한 통제 수단을 활용해서 프로그래머가 코드를 작성하도록 유도하고 있습니다.

오늘은 이 중에서 가장 많이 쓰린다고 볼 수 있는 **옵셔널(Optional)**에 대해서 알아봅시다 ^__^

[Apple Developer Documentation](https://developer.apple.com/documentation/swift/optional)

### 1. 옵셔널(Optional) 기본

옵셔널(Optional)은 **"값이 있을 수도 있고 없을 수도 있는 경우"**를 나타냅니다.

**값이 없을 수도 있다는 말이 무슨 말이지?** 라고 생각할 수 있으니 한 가지 예시를 들어보죠.

사용자가 회원가입을 하기 위해서 기본 정보를 입력하는 중이라고 가정해봅시다.

사용자가 문제없이 이름과 id, 비밀번호, 비밀번호 확인 칸까지 채우고, 핸드폰 번호를 입력하는 칸에서 만약 핸드폰을 사용하지 않는 사용자라면?

사용자는 "핸드폰 없음"을 따로 표시해주고 핸드폰 번호 입력란은 공란으로 남겨두게 될 것입니다.

이렇게 값이 들어올 수도, 들어오지 않을 수도 있는 경우를 처리하기 위해

Swift에서는 옵셔널(Optional)이라는 것을 사용합니다.

**참고로, 스위프트에서 값이 들어오지 않는 경우는 "nil"이라는 키워드를 사용해 표현하게 됩니다!**

옵셔널을 표시하는 방법은 아주 간단하게 **데이터 타입(Data Type) 옆에 "?"를 붙여주면 됩니다.**

```swift
var optionalNumber: Int?  // Int Optional형 optionalNumber 변수 선언
var number: Int           // Int형 number 변수 선언

optionalNumber = nil      **// 옵셔널 변수에는 값이 들어오지 않아도 가능하다!**
optionalNumber = 100
print(optionalNumber)     // Optional(100)

number = 100
number = nil              // Int형에는 값이 들어오지 않는 nil을 사용하면, 에러 발생
```

여기서 잠깐,

100이 들어있는 optionalNumber 변수를 print 해보면,

일반 100이 출력되는 것이 아니라, Optional(100)이라고 출력되는 모습을 주석에서 볼 수 있는데요.

이것은 변수를 출력 했음에도 "100이 있을 수도 없을 수도 있음"을 나타내는 것을 의미한다고 볼 수 있습니다.

그렇기 때문에, 우리가 정상적으로 이 값을 사용하기 위해서는

옵셔널에 들어있는 **"값을 꺼내는 과정"**이 필요하게 됩니다. 

이 과정을 우리는 "언래핑(Unwrapping)"이라고 부릅니다.

### 2. 옵셔널 값을 꺼내기 위한 두 가지 방법(언래핑)

언래핑에는 두 가지 방법이 있습니다.

옵셔널을 강제로 부수어 값을 꺼내 버리는 (과격한) **강제 언래핑**과

값이 있는지 체크한 다음, 값이 있을 경우에만 (친절하게) 동작을 하는 **옵셔널 바인딩**이 그 방법들입니다.

**(강제 언래핑은 매우 위험한 방법이니!! 실전에는 옵셔널 바인딩을 사용하도록 하자!!)**

먼저, **강제 언래핑은 "!"를 사용합니다**

옵셔널에 들어 있던 값을 "!"를 사용해서 꺼낸다면, 옵셔널을 깨부수고 원래 데이터를 가져오게 됩니다.

**"!"만 붙이면 되는 강제 언래핑 방식이 쉽고, 간단해 보이는데 위험하다는 이유는 뭘까요?**

옵셔널을 깨부수고 정상적으로 원래 데이터를 가져올 수 있는 경우는 옵셔널 안에 값이 들어있는 경우에 한정해서입니다. 

**그런데 만약, 옵셔널 안에 값이 들어있지 않다면?**

변수 안에는 값이 담겨있지 않으니 당연히 그 값을 접근하려고 하면 에러를 발생시키게 되겠죠...

이렇게 되면, 원래 안전성을 중시하는 Swift의 노력이 필요 없어지고, 프로그래머가 행할 수 있는 실수를 막을 방법이 없어지게 되는 것입니다

```swift
// 강제 언래핑 작동
optionalNumber = 100
number = optionalNumber!

// 강제 언래핑 에러
optionalNumber = nil
number = optionalNumber!    // 값이 비어있기 때문에 런타임 오류가 발생 (빌드는 가능)
```

과격했던(?) 강제 언래핑과 다르게 옵셔널 바인딩은 부드러운(?) 방식을 사용합니다.

친절하게 **if-let 구문을 사용해, 옵셔널에 값이 있는지 없는지를 확인**하고

만약 값이 있을 경우에는 조건문 안에 있는 코드가 작동,

값이 없을 경우(값이 nil일 경우)에는 else 구문 혹은 조건문을 통과하게 되는 것입니다.

```swift
// 옵셔널 바인딩
if let number: Int = optionalNumber {
        print(number)
} else {
        print("The value is nil")
}

print(number)    // number라는 항수는 if-let 안에서만 사용 가능! 
                                 // (사용 범위를 벗어낫기 때문에 여기서는 오류)
```

### 3. 옵셔널 바인딩 심화버전: guard

Swift에는 if-let 옵셔널 바인딩과 비슷한 guard라는 키워드도 존재합니다. 이 기회에 같이 알아둡시다!

guard는 구문 안에서 조건을 검사하고,

조건과 다른 값이 전달되었을 경우 특정 실행 구문을 빠르게 종료하는 용도입니다.

```swift
guard (조건) else { 조건이 else일때 실행되는 부분, break나 return과 같이 종료 구문 필수 }

guard let name = info["name"] as? String else {
        return
}
```

확실히 if-let과 guard-let은 사용도가 비슷하다는 것을 알 수 있는데, 그럼 이 둘의 차이점은 뭘까요?

**가장 크게는 상수(let)의 사용범위가 다릅니다.**

**if-let** 같은 경우에는 해당 구문이 true일 때를 블록 안에다 작성하기 때문에, 이 **블록을 벗어나 상수를 사용하는 것이 불가능합니다.**

하지만, **guard-let**은 해당 구문이 true이면 문제없이 코드가 진행되는 방식이기 때문에 해당 상수(or 변수)를 **메서드 내에 지역 상수처럼 자유롭게 사용할 수 있습니다.**

그러다 보니, 상수의 활용범위가 훨씬 넓은 guard-let 구문이 if-let 구문보다 자주 쓰이게 되죠!

**추가로는, else의 필수 사용 여부에서 차이가 납니다.**

if-let은 해당 조건이 **"참인 경우"**를 강조하는 문법이기 때문에 else 구문을 꼭 필수로 써주지 않아도 됩니다.

반면, guard는 해당 조건이 **"거짓인 경우"** 동작을 벗어나게끔 하는 문법이기 때문에 else 구문을 필수로 써줘야 하며, else 구문 안에는 동작을 종료시키기 위한 구문 return, break, continue, throw 같은 명령어를 꼭 써줘야 합니다!

```swift
// if-let과 guard-let과의 차이

/*
* 해당 Optional 값을 언래핑 하는 것은 동일!
* guard-let을 선언한 변수는 메소드 내에서 지역 상수처럼 사용 가능!
* if-let은 if문 안에서만 사용 가능!
*/

// if-let
func printName() {
        var value: String? = "minjae"
        print(value)      // Optional("minjae")
        if let name = value {
                // if문 안에서만 name 변수를 활용 가능
                print(name)
        }
}

// guard-let
func printName() {
        var value: String? = "minjae"
        print(value)      // Optional("minjae")
        guard let name = value else { return }
        // name 변수는 메소드 안에서 지역 변수처럼 활용 가능
        print(name)
}
```
