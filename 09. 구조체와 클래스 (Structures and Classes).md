이번 글에서는 구조체(Struct)와 클래스(Class)에 대해 아주 자세하게 다뤄보려 합니다!

내용 자체가 너무 중요해 조금 기니까, 원하는 부분을 빠르게 찾아가고 싶으면 아래 밑줄친 부분을 클릭해주시면 됩니다!

<aside>
💡 **구조체, 클래스 원하는 부분만 빠르게 살펴보기!**

[객체지향 프로그래밍의 특징과 구조체/클래스 용어 정리](https://www.notion.so/7-78c3ed06a94d4cd0883ddd310f2f56ed?pvs=21)

[구조체(struct)와 클래스(class)의 기본 형태 알아보기](https://www.notion.so/7-78c3ed06a94d4cd0883ddd310f2f56ed?pvs=21)

[구조체와 클래스의 차이점은?](https://www.notion.so/7-78c3ed06a94d4cd0883ddd310f2f56ed?pvs=21)

[값 타입(Call by Value)과 참조 타입(Call by Reference)](https://www.notion.so/7-78c3ed06a94d4cd0883ddd310f2f56ed?pvs=21)

[프로퍼티를 조금 더 깊게 공부해보자!](https://www.notion.so/7-78c3ed06a94d4cd0883ddd310f2f56ed?pvs=21)

[상속(Inheritance)이란?](https://www.notion.so/7-78c3ed06a94d4cd0883ddd310f2f56ed?pvs=21)

[인스턴스의 생성(init)과 소멸(deinit)](https://www.notion.so/7-78c3ed06a94d4cd0883ddd310f2f56ed?pvs=21)

</aside>

본격적으로 들어가기 전에, **객체지향 프로그래밍에서의 중요한 4가지 특성**을 먼저 알아야합니다.

왜냐고 물으신다면…

구조체와 클래스를 배우는 내용이 객체지향 프로그래밍에서의 중요한 특징에 많이 해당하기 때문인데요! 얼만큼 해당하는지 한번 살펴봅시다!

<aside>
💡 1️⃣ **추상화** : 객체의 공통적인 속성과 기능을 추출하여 정의하는 것 **[오늘 배울 클래스, 구조체와 관련]**

2️⃣ **캡슐화, 은닉화** : 목적에 따라 데이터 구조 및 처리 방법을 결합시키고, 외부에는 내부 기능 구현 내용을 감추고 이용방법만 알려주는 것 **[Swift에서는 접근제어에 해당하는 내용입니다. 접근제어는 뒤에 나옵니다!]**

3️⃣ **상속** : 상위 개념의 특징을 하위 개념이 물려받아 사용하는 것, 재사용을 위함 **[오늘 배울 클래스, 구조체와 관련]**

4️⃣ **다형성 (Polymorphism)** : 한 객체가 다른 여러형태(객체)로 재구성되는 것 **[오늘 배울 클래스, 구조체와 관련]**

</aside>

구조체(Struct)와 클래스(Class)는 기본적으로 **데이터를 용도에 맞게 묶어 표현하고자 할 때** 유용한 기능입니다.

조금 풀어서 말하자면, 구조체와 클래스는 모두 ‘프로퍼티'와 ‘메서드'를 사용하여 구조화된 데이터와 기능을 가질 수 있고, 하나의 데이터 타입을 만드는 역할을 하는 애들입니다.

용어가 헷갈리는 분들을 위해, 용어들도 확실하게 정리해보겠습니다!

<aside>
💡 1️⃣ 인스턴스(instance) : 클래스/구조체에서 생성된 **객체** (= 구조체와 구조체라는 틀(frame)안에서 찍어낸 내용물)

2️⃣ 프로퍼티(property) : 클래스/구조체 객체(= 인스턴스)에 들어있는 **정보, 값**

3️⃣ 메서드(method) : 클래스/구조체 객체(= 인스턴스)에 들어있는 **함수**

</aside>

### **1. 구조체(Struct)와 클래스(Class) 기본 형태**

---

그럼 이제 묻지도 따지지도 않고, 구조체와 클래스를 어떻게 사용하는지 알아보겠습니다.

위에서 인스턴스, 프로퍼티, 메서드라는 용어를 이미 배웠으므로 이제부터는 이 용어들을 자유롭게 섞어가면서 설명을 하겠습니다. ^_^

우선 구조체는 **struct**라는 키워드를 사용해서 만들어줍니다.

그리고 아래 코드를 보면, 프로퍼티와 메서드 인스턴스를 각각 어떤 식으로 생성하는지 확인할 수 있습니다!

아래 코드를 보면서 주목해야 할 부분은 **각 인스턴스와 프로퍼티에 따라서 수정 여부가 어떻게 차이가 나는지**에 대한 부분입니다.

참고로, 여기서 말하는 **가변**은 변할 수 있는 변수(var), **불변**은 변할 수 없는 상수(let)를 의미한다고 보면 됩니다!

```swift

struct SampleStruct {
    var mutableProperty: Int = 100         // 가변 프로퍼티
    let immutableProperty: Int = 100       // 불변 프로퍼티
    static var typeProperty: Int = 100     // 타입 프로퍼티: SampleStruct타입 자체에서만 사용 가능
    
    func instanceMethod() {                // 인스턴스 메서드
        print("instanceMethod")
    }
    static func typeMethod() {             // 타입 메서드
        print("typeMethod")
    }
}

// 가변 인스턴스
var mutable: Sample = Sample()
mutable.mutableProperty = 200         // 가변 인스턴스 내부의 가변 프로퍼티: 수정 o
mutable.immutableProperty = 200       // 가변 인스턴스 내부의 불변 프로퍼티: 수정 x

// 불변 인스턴스
let immutable: Sample = Sample()
immutable.mutableProperty = 200       // 불변 인스턴스 내부의 가변 프로퍼티: 수정 x
immutable.immutableProperty = 200     // 불변 인스턴스 내부의 불변 프로퍼티: 수정 x
```

클래스는 **class**라는 키워드를 사용해서 만들어줍니다.

클래스도 구조체와 마찬가지로 타입을 정의하는 문법이기 때문에 UpperCamelCase를 사용해서 네이밍을 지정해줘야 합니다!

위의 구조체와 비교했을 때, `class func` 키워드를 사용한 재정의 가능한 타입 메서드 부분이 추가된 것을 확인할 수 있습니다.

이 부분은 아래에서 다룰 상속 부분과 연관되어 있는 클래스만의 고유한 특징이라고 볼 수 인데요, 

상속은 밑에서 더 자세하게 다룹니다!

추가로, 불변 인스턴스 내부에 가변 프로퍼티가 있는 경우에도 구조체와 차이점이 존재하는 것을 확인할 수 있습니다.

변하지 않는 클래스나 구조체 안에 있는 var 프로퍼티는 클래스의 경우에만 수정이 가능하다고 한다. 

이는 클래스가 참조 타입(Call by Reference)인 것과 연관되어 있는데, 이 역시도 아래에서 집중적으로 다뤄보도록 하겠다.

```swift
class SampleClass {
    var mutableProperty: Int = 100         // 가변 프로퍼티
    let immutableProperty: Int = 100       // 불변 프로퍼티
    static var typeProperty: Int = 100     // 타입 프로퍼티: SampleClass타입 자체에서만 사용 가능
    
    func instanceMethod() {                // 인스턴스 메서드
        print("instanceMethod")
    }
    static func typeMethod() {             // 타입 메서드
        print("typeMethod")
    }
    class func classMethod() {             // 재정의 기능 타입 메서드 - 상속과 관련
        print("type method - class")
    }
}

// 가변 인스턴스
var mutableReference: Sample = Sample()
mutable.mutableProperty = 200         // 가변 인스턴스 내부의 가변 프로퍼티: 수정 o
mutable.immutableProperty = 200       // 가변 인스턴스 내부의 불변 프로퍼티: 수정 x

// 불변 인스턴스
let immutableReference: Sample = Sample()
// 클래스 인스턴스는 참조 타입(구조체와 다른부분)
immutable.mutableProperty = 200       // 불변 인스턴스 내부의 가변 프로퍼티: 수정 o 
immutable.immutableProperty = 200     // 불변 인스턴스 내부의 불변 프로퍼티: 수정 x
```

### **2. 구조체와 클래스의 차이점**

---

그럼 위에서 다룬 내용 말고도 구조체와 클래스의 차이점은 어떤 것들이 있을까요? 표로 정리해봤습니다!

값 타입/참조 타입과 상속에 대한 내용은 밑에서 더 다뤄볼겁니다!

타입 캐스팅은 #9 글을 참조해주시면 됩니다 ^__^

| 구조체 (Struct) | 클래스 (Class) |
| --- | --- |
| 값 타입(Call by Value) | 참조 타입(Call by Reference) |
| 상속 불가능 | 상속 가능 |
| 레퍼런스 형태가 아니기 때문에 공유가 불가능 | 레퍼런스 형태이므로, 공유가 가능 |
| 스택 메모리 영역에 할당 (속도가 빠름) | 힙 메모리 영역에 할당 |
| AnyObject로 타입 캐스팅이 불가능 | AnyObject로 타입 캐스팅이 가능 |

### **3. 값 타입(Call by Value)과 참조 타입(Call by Reference)**

---

데이터를 전달할 때, 값을 복사해서 전달하느냐, 해당 값의 메모리 위치를 전달하느냐에 따라서 값 타입(Call by Value)과 참조 타입(Call by Reference)이 나뉘게 됩니다. (값 복사-> 값 타입, 메모리 위치 전달 -> 참조 타입)

위에서는 **구조체(Struct)는 값 타입**, **클래스(Class)는 참조 타입**이라고 구분되어 있는데, 어떻게 다른 건지 코드에서 직접 확인해보도록 하자!

```swift
// 구조체와 클래스를 하나씩 선언해두고, 그 안에 가변 프로퍼티를 하나씩 만들어두자.
struct ValueType {
    var property: Int = 0
}

class ReferenceType {
    var property: Int = 0
}
```

구조체는 값 타입이기 때문에, 데이터를 전달할 때 **값을 복사**하여 전달할 것입니다.

즉, `firstStructInstace`라는 이름의 구조체를 `secondStructInstace`에 대입해서 또 다른 인스턴스를 하나 더 만들어준 후, `secondStructInstace` 구조체에 담겨있는 프로퍼티 값을 수정한 경우,

`firstStructInstace`와 `secondStructInstace`는 값만 **복사됐을** 뿐, 

그 실체는 엄연히 다른 애이기 때문에 `secondStructInstace`의 프로퍼티 값을 2로 수정하더라도 `firstStructInstace`의 프로퍼티 값이 함께 **수정되지 않게 되는 것을 확인할 수 있습니다.**

```swift
let firstStructInstace = ValueType()
let secondStructInstace = firstStructInstace
secondStructInstace.property = 2

print(firstStructInstace.property)      // 0 (값의 위치가 복사 됬을뿐, 둘은 다르기 때문에 변경된 값이 반영되지 않는다.)
print(secondStructInstace.property)     // 2
```

반면, 클래스는 참조 타입이기 때문에 데이터를 전달할 때, **값의 메모리 위치를 전달합니다.**

즉, `firstClassInstace`와 `secondClassInstace`는 같은 메모리 위치를 가리키고 있는 완벽히 뿌리까지 같은 애이기 때문에, 

여기서는 어느 프로퍼티 값을 수정하더라도, 두 인스턴스의 프로퍼티 값이 모두 바뀌게 되는 것이죠!

```swift
let firstClassInstace = ReferenceType()
let secondClassInstace = firstClassInstace
secondClassInstace.property = 2

print(firstClassInstace.property)      // 2 (두 인스턴스가 가리키는 위치가 같으므로, 변경된 값이 반영됩니다.)
print(secondClassInstace.property)     // 2
```

그러니 만약 특정한 데이터를 묶고자, frame을 만들고자 할 때, struct와 class 중에서 어떤 것을 활용할지 고민하고 있다면,

생성한 인스턴스가 참조가 되어야 하는지, 복사가 되어야 하는지에 따라서 차이를 둘 수 있을 겁니다!

만약 덩어리 객체를 만들어야 하는데 복사가 되어야 한다면 구조체(Struct)를, 참조를 해야 한다면 클래스(Class)를 사용하면 되겠죠?

### **4. 프로퍼티를 조금 더 깊게 공부해보자!**

---

프로퍼티(Property)에 대해서도 조금 더 자세하게 알아보겠습니다.

프로퍼티는 위에도 언급했다시피, 클래스, 구조체에 구현을 해줘서 타입과 연관된 값들을 표현할 때 사용하는 녀석인데요.

프로퍼티는 종류가 많기 때문에, 각 프로퍼티 별로 어떤 특징이 있는지 알아둘 필요가 있다고 합니다!

일단, 공통적으로 프로퍼티의 값이 변할 수 있으면 **가변**, 변하지 않으면 **불변**이라고 앞에 붙이게 됩니다.

우선, 가장 기본적으로 **인스턴스 저장 프로퍼티**가 있습니다.

이 프로퍼티는 말 그대로 인스턴스 내부에서 값을 저장하는 데 사용할 수 있는 프로퍼티인데요, 우리에게 아주 자주 보이는 녀석입니다.

```swift
struct ExampleStruct {
    let value: Int
    var length: Int
}
```

두 번째는 타입 자체에서 사용할 수 있는 **타입 저장 프로퍼티**가 있습니다.

인스턴스 저장 프로퍼티에서 간단하게 **static**이라는 키워드만 붙여주는 방식으로 만들어줍니다!

타입 저장 프로퍼티란 위에 인스턴스 저장 프로퍼티와 비교했을 때, 각각의 인스턴스가 아닌 **타입 자체에 속하는 프로퍼티**입니다..!

그니깐, 인스턴스의 생성 여부와 관계없이 타입 저장 프로퍼티의 값은 하나일 수밖에 없고, 그 값은 해당 클래스/구조체 타입의 모든 인스턴스가 공통으로 사용하게 되는 셈이죠!

다시 말해, 모든 인스턴스에서 공용으로 사용할 값을 정의할 때는 타입 저장 프로퍼티를 사용하면 되겠습니다. (전역 변수 같은 개념이다 ^__^)

```swift
struct Student {
    static var typeDescription: String = "학생"
}
```

세 번째는 **연산 프로퍼티**가 있습니다.

연산 프로퍼티란 말 그대로 특정한 연산을 목적으로 만든 프로퍼티를 의미하고, **get(접근자)**과 **set(생성자)** 키워드로 나뉘게 됩니다.

접근자와 생성자를 사용하려면, 이 값을 **저장할 변수가 1개 이상 반드시 있어야 하며**, 그 변수는 연산을 통해 값이 수정될 수 있기 때문에 **불변(let 상수)이 아니라, 가변(var 변수) 형태로 선언**되어야 한다는 점이 특징입니다.

get과 set을 함께 사용하거나, 혹은 get만 사용하는 것은 가능하다. (set혼자만 사용하는 것은 불가능!)

- **접근자(get, getter)**는 인스턴스 내, 외부의 값의 연산을 수행해 연산된 결괏값을 return 하는 역할
- **생성자(set, setter)**는 은닉화된 내부의 프로퍼티 값을 간접적으로 설정하는 역할

```swift
struct Person {
    // 인스턴스 저장 프로퍼티
    var name: String = ""
    var koreanAge: Int = 22
    
    // 인스턴스 연산 프로퍼티
    var westernAge: Int {
        get {                            // get을 사용해서 해당 westernAge를 호출했을 때, 연산값을 반환
            return koreanAge - 1
        }
        
        set(inputValue) {                // set을 설정해서 기존 저장 프로퍼티의 값에 새로운 값을 할당
            koreanAge = inputValue + 1
        }
    }
}

var minjae: Person = Person()
print(minjae.westernAge)       // 21 (get 사용)

minjae.westernAge = 25
print(minjae.koreanAge)        // 26 (set 사용)
```

추가로, 프로퍼티를 배운 김에 프로퍼티 감시자까지 배워보겠습니다!

**프로퍼티 감시자**란 저장 프로퍼티에만 사용 가능한 기능으로, 해당 프로퍼티에 값을 할당하기 전/후(= 프로퍼티의 값이 변경된 직전/직후)에 원하는 동작이 있다면 추가할 수 있는 부분을 의미합니다.

뷰 컨트롤러의 생명주기가 will과 did로 나누어졌던 것처럼, 

여기서도 프로퍼티가 변경되기 직전은 `willSet`, 변경된 이후는 `didSet`이라는 블록으로 사용하게 됩니다!

```swift
struct Money {
    var currencyRate: Double = 1100 {
        // 저장 프로퍼티가 변경되기 직전에 호출
        willSet(newRate) {
            print("환율이 \(currencyRate)에서 \(newRate)으로 변경될 예정입니다.")
        }
        
        // 저장 프로퍼티가 변경되기 직후에 호출
        didSet(oldRate) {
            print("환율이 \(oldRate)에서 \(currencyRate)으로 변경되었습니다.")
        }
    }
}

var moneyInMyPocket: Money = Money()

// 변경되기 전, "환율이 1100에서 1000으로 변경될 예정입니다."가 print됨
moneyInMyPocket.currencyRate = 1000
// 변경된 이후, "환율이 1100에서 1000으로 변경되었습니다."가 print됨
```

### **5. 상속(Inheritance)**

---

위에서 구조체는 상속이 불가능하고, 클래스는 상속이 가능하다고 했던 것 기억하시나요 혹쉬.....? 

중요한 부분이라 까먹으면 안ㄷ..

드디어 상속에 대해 배워볼 시간입니다!

부모와 자식 간의 재산 상속이 이뤄지는 일상생활에서의 상속 의미와 마찬가지로, 

Swift에서는 **"클래스의 프로퍼티와 메서드가 부모에서 자식으로 전달되는 것"**을 상속이라 부릅니다.

앞으로, 프로퍼티와 메서드를 **전달해주는** 클래스를 → **부모 클래스**,

프로퍼티와 메서드를 **전달받는** 클래스를 → **자식 클래스**라 통칭해서 부르겠습니다!

**swift 상속의 특징은 다음과 같습니다!**

<aside>
💡 1️⃣ 클래스/프로토콜에서만 가능, 열거체/구조체에서는 불가능

2️⃣ 단일 상속만 가능 (단 하나의 클래스만 상속이 가능, 대신 프로토콜은 여러 개를 채택하는 것도 가능)

3️⃣ 상속받은 클래스도 새로운 자식 클래스에게 상속이 가능

</aside>

아래 코드를 살펴보면서 실제 상속이 어떻게 이루어지는지 자세하게 알아보죠!

먼저 `Vehicle`이라는 클래스를 만듭니다.

Vehicle 안에는 가변 저장 프로퍼티 `currentSpeed`와 가변 연산 프로퍼티 `description`, 인스턴스 메서드 `makeNoise`가 존재합니다.

그리고 Vehicle 부모 클래스를 상속받은 Bicycle 클래스와 Train 클래스를 생성해준 것을 확인할 수 있습니다!

상속에서 이용할 수 있는 키워드는 아래와 같습니다. 

아래 코드를 보면서 확인해주세요!

- `override`: 부모 클래스에서 하위 클래스로 물려준 인스턴스나 메소드를 본인 클래스에 맞게 재정의 하는 것
- `super`: 재정의를 하고 싶은데, 부모 클래스의 내용을 그대로 가져오고 싶을 때
- `final`: 자식 쪽에서 재정의되면 안될 내용의 메소드나 프로퍼티

```swift
class Vehicle {
    var currentSpeed = 0.0              // 가변 저장 프로퍼티
    var description: String {           // 가변 연산 프로퍼티
        return "traveling at \(currentSpeed) miles per hour"
    }
    func makeNoise() {                  // 인스턴스 메소드
        print("🔥")
    }
}

let car: Vehicle = Vehicle()
print("Vehicle: \(car.description)")    // Vehicle: traveling at 0.0 miles per hour 출력

// Vehicle이라는 부모 클래스를 상속받은 Bicycle 클래스
// Bicycle 클래스에는 currentSpeed, description 프로퍼티와 makeNoise 메서드까지 모두 담겨있음
class Bicycle: Vehicle {
    var hasBasket: Bool = false
}

// Vehicle이라는 부모 클래스를 상속받은 Train 클래스
// override: 부모 클래스에서 하위 클래스로 물려준 인스턴스나 메소드를 본인 클래스에 맞게 재정의 하는 것
class Train: Vehicle {
    override func makeNoise() {
        print("🔈")
    }
}

// Vehicle이라는 부모 클래스를 상속받은 Car 클래스
// super: 재정의를 하고 싶은데, 부모 클래스의 내용을 그대로 가져오고 싶을 때
class Car: Vehicle {
    override func makeNoise() {
        super.makeNoise()
        print("🔈")
    }
}

// final: 자식 쪽에서 재정의되면 안될 내용의 메소드나 프로퍼티
class Vehicle {
    final var currentSpead = 0.0
}
```

### **6. 인스턴스의 생성(init)과 소멸(deinit)**

---

프로퍼티에 대한 기본값을 설정하기가 애매하다면, (각 인스턴스마다 값이 달라져야 한다면) 

**`init`(생성자) 키워드**를 통해 클래스의 인스턴스를 생성할 때, 프로퍼티의 값을 어떻게 처리할지 정할 수도 있습니다.

이때, `init`(이니셜 라이저) 안에는 **모든 프로퍼티에 대한 초기값이 정의가 되어 있어야 한다**는 것을 항상 조심해야 합니다! (물론, 프로퍼티가 옵셔널로 선언되어 있으면 정의하지 않아도 됩니다 ^__^)

```swift
class Person {
    var name: String
    var age: Int
    var nickName: String?        // 옵셔널로 프로퍼티 선언
    
    // init(생성자)을 활용하여, 클래스의 인스턴스를 생성할 때 프로퍼티의 값을 어떻게 처리할지 정함
    init(name: String, age: Int, nickName: String) {
        self.name = name
        self.age = age
        self.nickName = nickName
    }
    
    // 옵셔널로 되어 있을 때는 초깃값을 정하지 않아도 좋음
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    
}

let minjae: Person = Person(name: "minjae", age: 22)
let minjae: Person = Person(name: "minjae", age: 22, nickName: "미니민")
```

또는 아래 코드처럼, 

특정 조건을 만족하지 않을 경우에는 인스턴스를 생성하지 않도록 하는 방법도 있다고 합니다!

```swift
class Person2 {
    var name: String
    var age: Int
    var nickName: String?        // 옵셔널로 프로퍼티 선언
    
    // 특정 조건을 걸어서, 일정 조건을 충족하지 않으면 인스턴스를 생성하지 않도록 함
    init?(name: String, age: Int) {
        if (0...120).contains(age) == false {
            return nil
        }
        
        if name.characters.count == 0 {
            return nil
        }
        
        self.name = name
        self.age = age
    }
}

let mini: Person2? = Person(name: "mini", age: 123)   // nil
let mini2: Person2? = Person(name: "", age: 22)        // nil
```

생성하는 **init(생성자)**가 있었다면, 

반대로, 해제하는 **deinit(소멸자)도** 존재하겠죠?

이 부분은 인스턴스가 메모리에서 해제되는 시점에 **자동으로 호출**되는 부분이며, 사용자가 직접 호출할 수는 없습니다!

```swift
class Person2 {
    var name: String
    var pet: Pyppy?
    var child: Person
    
    init(name: String, child: Person) {
        self.name = name
        self.child = child
    }
    
    // 인스턴스가 메모리에서 해제될 때 호출
    deinit {
        if let petName = pet?.name {
            print("\\(name)가 \\(child.name)에게 \\(petName)를 인도합니다.")
            self.pet?.owner = child
        }
    }
}
```
