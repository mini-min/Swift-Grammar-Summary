
### 1️⃣ **ARC(Automatic Reference Counting)**란?

---

- 앱의 메모리 사용을 자동으로 관리 해주는 기능
- 컴파일 시 코드를 분석해서 자동으로 `retain`, `release` 코드를 생성해주는 것.
- 참조된 횟수를 추적해 더 이상 참조되지 않는 인스턴스를 메모리에서 해제해 주는 것.
- ARC는 자동으로 RC(Reference Counting)를 관리해주기 때문에 메모리 해제에 대한 개발자의 부담을 덜어준다.

### 2️⃣ **strong (강한 참조)**

---

- 해당 인스턴스의 소유권을 가진다.
- 자신이 참조하는 인스턴스의 retain count를 +1씩 증가시킨다.
- 값 지정 시점에 `retain`이 되고 참조가 종료되는 시점에 `release`가 된다.
- 선언할 때 아무것도 적어주지 않으면 default로 strong이 된다.

```swift
var test = Test()  // retain count 1 증가
test = nil         // retain count가 1 감소되어 0이 되면서 메모리 해제됨
```

`strong` 참조 방식은 이렇게 객체를 서로 소유하려고 하는 특성 때문에, 

순환참조란 것이 발생해서 **메모리 누수(Memory Leak)**가 발생할 수 있다고 합니다.

→ **메모리 누수**에 대해서는 더 깊게 스스로 공부해보시면 좋을 것 같아요!

### 3️⃣ **weak (약한 참조)**

---

- 해당 인스턴스의 소유권을 가지지 않고, 주소값만을 가지고 있는 포인터 개념입니다.
- 자신이 참조하는 인스턴스의 retain count를 증가시키지 않고, release도 발생하지 않습니다.
- 자신이 참조는 하지만 weak 메모리를 해제시킬 수 있는 권한은 다른 클래스에 있는데요, 메모리가 해제될 경우 자동으로 레퍼런스가 nil로 초기화를 해준다고 합니다.
- weak 속성을 사용하는 객체는 항상 optional타입 이어야 합니다!. → (해당 객체가 nil일 수 있기 때문)

```swift
weak var test = Test()  // 객체가 생성 되지만 weak이기 때문에 바로 객체가 해제되어 nil이 됨
```

### 4️⃣ **unowned (미소유 참조/약한 참조)**

---

- 해당 인스턴스의 소유권을 가지지 않는 경우입니다.
- 자신이 참조하는 인스턴스의 retain count를 증가시키지 않습니다.
- nil이 될 수 없습니다. 즉, optional로 선언 되어서는 안된다는 뜻이겠죠?
- weak와 달리 nil이 될 수 없기 때문에, 반드시 인스턴스가 메모리에서 해제되지 않을 때에만 사용해야 합니다!

```swift
unowned var test = Test()  // 객체 생성과 동시에 해제되고 댕글링 포인트만 가지고 있음. 에러남.
```

<aside>
🌟 **weak와 unowned 차이점?**

`weak`는 객체를 계속 추적하면서 객체가 사라지게 되면 nil로 바꾸게 됩니다.

하지만, `unowned`는 객체가 사라지게 되면 댕글링 포인터가 남습니다. (nil이 아님)

이 댕글링 포인터를 참조하게 되면 crash가 나게 되는데, 

이 때문에 unowned는 사라지지 않을거라고 보장되는 객체에만 설정하여야 한다는 점이 차이가 되겠습니다!

> **댕글링 포인터(Dangling pointer)란?** 
원래 바라보던 객체가 해제되면서 할당되지 않는 공간을 바라보는 포인터.
> 
</aside>

### ✔️ 정리

---

| strong (강한 참조) | 레퍼런스 카운트를 증가시켜 ARC로 인한 메모리 해제를 피하고,
객체를 안전하게 사용하고자 할 때 쓰인다. |
| --- | --- |
| weak (약한 참조) | 대표적으로 retain cycle에 의해 메모리가 누수되는 문제를 막기 위해 사용되며, 
delegate 패턴이 있다. |
| unowned (미소유 참조) | 객체의 라이프사이클이 명확하고 개발자에 의해 제어 가능이 명확한 경우, 
weak Optional 타입 대신 사용하여 간결한 코딩이 가능하다. |
